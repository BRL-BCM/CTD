% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mle.getPtDist.r
\name{mle.getPtDist}
\alias{mle.getPtDist}
\title{Patient distance metric based on the mutual information of patients' highly connected perturbed metabolite sets.}
\usage{
mle.getPtDist(p1.optBS, ptID, p2.optBS, ptID2, data_mx, ranks)
}
\arguments{
\item{p1.optBS}{- The optimal bitstring associated with patient 1.}

\item{ptID}{- The identifier associated with patient 1's sample.}

\item{p2.optBS}{- The optimal bitstring associated with patient 2.}

\item{ptID2}{- The identifier associated with patient 2's sample.}

\item{data_mx}{- The matrix that gives the perturbation strength (z-scores) for all variables (columns) for each patient (rows).}

\item{ranks}{- The list of node ranks, starting with each node in patient 1&2's subsets of interest.}
}
\value{
patientDistances - a distance matrix, where row and columns are patient identifiers.
}
\description{
This function calculates the universal distance between patients, using a mutual information metric, where self-information comes from the minimum encoding length of each patient's encoded modular perturbations in the background knowledge graph.
}
\examples{
# Get patient distances for the first 4 patients in the Miller et al 2015 dataset.
data("Miller2015")
data_mx = Miller2015[-grep("x - ", rownames(data_mx)),grep("IEM", colnames(Miller2015))]
data_mx = data_mx[,c(1:4)]
# Look at the top 15 metabolites for each patient. 
kmx=15
topMets_allpts = c()
for (pt in 1:ncol(data_mx)) { topMets_allpts = c(topMets_allpts, rownames(data_mx)[order(abs(data_mx[,pt]), decreasing=TRUE)[1:kmx]]) }
topMets_allpts = unique(topMets_allpts)
# Pre-compute node ranks for all metabolites in topMets_allpts for faster distance calculations.
ranks = list()
for (n in 1:length(topMets_allpts)) { ranks[n] = singleNode.getNodeRanksN(n, G, p1=0.9, thresholdDiff=0.01, adj_mat) }
names(ranks) = topMets_allpts
# Also pre-compute patient bitstrings for faster distance calculations.
ptBSbyK = list()
for (pt in 1:ncol(data_mx)) {
  S = rownames(data_mx)[order(abs(data_mx[,pt]), decreasing=TRUE)[1:kmx]]
  ptBSbyK[[ptID]] = singleNode.getPtBSByK(S, ranks)
}
# Build your results ("res") list object to store patient distances at different size k's.
res = list()
t = list(ncd=matrix(NA, nrow=ncol(data_mx), ncol=ncol(data_mx)))
rownames(t$ncd) = colnames(data_mx)
colnames(t$ncd) = colnames(data_mx)
for (i in 1:kmx) { res[[i]] = t }
for (pt in 1:ncol(data_mx)) {
  print(pt)
  ptID = colnames(data_mx)[pt]
  for (pt2 in pt:ncol(data_mx)) {
    ptID2 = colnames(data_mx)[pt2]
    tmp = mle.getPtDist(ptBSbyK[[ptID]], ptID, ptBSbyK[[ptID2]], ptID2, data_mx, ranks)
    for (k in 1:kmx) {
      res[[k]]$ncd[ptID, ptID2] = tmp$NCD[k]
      res[[k]]$ncd[ptID2, ptID] = tmp$NCD[k]
    }
  }
}
}
