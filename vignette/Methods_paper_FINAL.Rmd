---
title: "Methods Paper (Nucleotide Disorders)"
author: "Lillian Thistlethwaite"
date: "3/19/2019"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
```

## Data Load
Seven untargeted metabolomics profiles with confirmed pathogenic ABAT variants (Kennedy et al, 2019), 3 untargeted metabolomics profiles with confirmed pathogenic AADC variants (Atwal et al, 2015, Pappan et al, 2017), and 3 ADSL variants (Donti et al, 2016) were used in this analysis, as well as 161 undiagnosed metabolomics profiles and accompanying whole exome sequencing (WES) genetic variation (.vcf) data.
```{r get-data}
require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
```

## Plot Patient's Metabolomic Profiles onto Pathway Maps
``` {r pathway-vis}
# ABAT patients
#plot.pathwayMap("allPathways", "ABAT001", data_mx[,"ABAT001"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT002", data_mx[,"ABAT002"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT003", data_mx[,"ABAT003"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT004", data_mx[,"ABAT004"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT005", data_mx[,"ABAT005"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT006", data_mx[,"ABAT006"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "ABAT007", data_mx[,"ABAT007"], 1, 1, getwd())
# AADC patients
#plot.pathwayMap("allPathways", "AADC001", data_mx[,"AADC001"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "AADC002", data_mx[,"AADC002"], 1, 1, getwd())
#plot.pathwayMap("allPathways", "AADC003", data_mx[,"AADC003"], 1, 1, getwd())
# ADSL patients
plot.pathwayMap("allPathways", "ADSL001", data_mx[,"ADSL001"], 1, 1, getwd())
plot.pathwayMap("allPathways", "ADSL002", data_mx[,"ADSL002"], 1, 1, getwd())
# Figure 7: ADSL003 with zscore.threshold=2
plot.pathwayMap("allPathways", "ADSL003", data_mx[,"ADSL003"], 2, 1, getwd())

#pathway.ListMaps_metabolon()
#plot.pathwayMap("TCA-Cycle", "ABAT001", abat_data[,"ABAT001"], 1, 2, getwd())
# For PNG (not SVG)
#plot.pathwayMap("TCA-Cycle", "ABAT001", abat_data[,"ABAT001"], 1, 2, getwd(), FALSE)
#plot.pathwayMap("Asp-Glu-Metabolism", "ABAT001", abat_data[,"ABAT001"], 1, 2, getwd(), FALSE)
#plot.pathwayMap("FattyAcid-Metabolism", "ABAT001", data_mx[,"ABAT001"], 1, 1, getwd(), FALSE)
```

## Interpret Patient Metabolomics Profiles with Over-Representation Analysis
``` {r ora}
# ABAT patients: selected X624685 for visualization
stats.getORA_Metabolon(data_mx[,"ABAT001"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ABAT002"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ABAT003"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ABAT004"], threshold = 2, type = "zscore") ## This one
stats.getORA_Metabolon(data_mx[,"ABAT005"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ABAT006"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ABAT007"], threshold = 2, type = "zscore")

# AADC patients: Selected X624843 for visualization
stats.getORA_Metabolon(data_mx[,"AADC001"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"AADC002"], threshold = 2, type = "zscore") ## This one
stats.getORA_Metabolon(data_mx[,"AADC003"], threshold = 2, type = "zscore")

# ADSL patients: selected X650033 for visualization
stats.getORA_Metabolon(data_mx[,"ADSL001"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ADSL002"], threshold = 2, type = "zscore")
stats.getORA_Metabolon(data_mx[,"ADSL003"], threshold = 2, type = "zscore") ## This one

```

## Interpret Patient Metabolomics Profiles with Metabolite-Set Enrichment Analysis
``` {r msea}
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/msea/")
# To learn how to build a pathway pathway knowledgebase GMT file, see msea_custom.Rmd

#### ABAT patients ####
require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
load(system.file("networks/bg_abat_maps_naive.RData", package="CTD"))
data_mx2 = data_mx[which(rownames(data_mx) %in% V(ig_pruned)$name), grep("REF|ABAT", colnames(data_mx))]
diags = colnames(data_mx2)
diags[-grep("ABAT", diags)] = "control"
diags[grep("ABAT", diags)] = "abat"
data_mx2 = data_mx2[, order(diags)]
data_mx2 = cbind(rep(NA, nrow(data_mx2)), data_mx2)
colnames(data_mx2)[1] = "DESCRIPTION"
write.table(data_mx2, file="EDTA_abat.gct", sep="\t", quote=FALSE, row.names = TRUE)
abs_filename_dataset = "EDTA_abat.gct"
# Or, if you want to save your dataset (.gct) for re-use, save them in the extdata folder of your CTD installation itself!
#write.table(data_mx2, file=system.file("extdata/MSEA_Datasets/EDTA_abat.gct", package="CTD"), sep="\t", quote=FALSE, row.names = TRUE)
#abs_filename_dataset = system.file("extdata/MSEA_Datasets/EDTA_abat.gct", package="CTD")

diag.ind = colnames(data_mx2)[-1]
diag.ind[-grep("ABAT", diag.ind)] = 0
diag.ind[grep("ABAT", diag.ind)] = 1
diag.ind = as.numeric(diag.ind)
diag.ind[which(diag.ind==1)] = "D"
diag.ind[which(diag.ind==0)] = "C"
diag.ind = paste(diag.ind, collapse=" ")
# Add num_samples 1 2, where num_samples is a numeric value equal to the nrow(data_mx2)-1
# Add #disease control
write.table(diag.ind, file="EDTA_abat.cls", sep=" ", quote=FALSE, row.names = FALSE, col.names = FALSE)
abs_filename_classes = "EDTA_abat.cls"
# Or, if you want to save your class labels (.cls) for re-use, save them in the extdata folder of your CTD installation itself! 
## CAUTION: Make sure you go back into it and add those 2 lines though.
#write.table(diag.ind, file=system.file("extdata/MSEA_Datasets/EDTA_abat.cls", package="CTD"), sep=" ", quote=FALSE, row.names = FALSE, col.names = FALSE)
#abs_filename_classes = system.file("extdata/MSEA_Datasets/EDTA_abat.cls", package="CTD")

# ABAT patients: selected X624685 for visualization
abat_msea = stats.getMSEA_Metabolon(abs_filename_dataset, abs_filename_classes, pathway_knowledgebase = "Metabolon", output_dir = getwd(), expt_name="abat")
abat_msea = abat_msea$report2[,c("MS", "SIZE", "NES", "NOM p-val", "FDR q-val")]
abat_msea[order(abat_msea$`FDR q-val`, decreasing = FALSE), ]


#### AADC patients ####
require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
load(system.file("networks/bg_aadc_maps_naive.RData", package="CTD"))
data_mx2 = data_mx[which(rownames(data_mx) %in% V(ig_pruned)$name), grep("REF|AADC", colnames(data_mx))]
diags = colnames(data_mx2)
diags[-grep("AADC", diags)] = "control"
diags[grep("AADC", diags)] = "aadc"
data_mx2 = data_mx2[, order(diags)]
data_mx2 = cbind(rep(NA, nrow(data_mx2)), data_mx2)
colnames(data_mx2)[1] = "DESCRIPTION"
write.table(data_mx2, file="EDTA_aadc.gct", sep="\t", quote=FALSE, row.names = TRUE)
abs_filename_dataset = "EDTA_aadc.gct"

diag.ind = colnames(data_mx2)[-1]
diag.ind[-grep("AADC", diag.ind)] = 0
diag.ind[grep("AADC", diag.ind)] = 1
diag.ind = as.numeric(diag.ind)
diag.ind[which(diag.ind==1)] = "D"
diag.ind[which(diag.ind==0)] = "C"
diag.ind = paste(diag.ind, collapse=" ")
# Add #num_samples 1 2, where num_samples is a numeric value equal to the nrow(data_mx2)-1
# Add #disease control
write.table(diag.ind, file="EDTA_aadc.cls", sep=" ", quote=FALSE, row.names = FALSE, col.names = FALSE)
abs_filename_classes = "EDTA_aadc.cls"

aadc_msea = stats.getMSEA_Metabolon(abs_filename_dataset, abs_filename_classes, pathway_knowledgebase = "Metabolon", output_dir = getwd(), expt_name="aadc")
aadc_msea = aadc_msea$report2[,c("MS", "SIZE", "NES", "NOM p-val", "FDR q-val")]
aadc_msea[order(aadc_msea$`FDR q-val`, decreasing = FALSE), ]


#### ADSL patients ####
require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
load(system.file("networks/bg_adsl_maps_naive.RData", package="CTD"))
data_mx2 = data_mx[which(rownames(data_mx) %in% V(ig_pruned)$name), grep("REF|ADSL", colnames(data_mx))]
diags = colnames(data_mx2)
diags[-grep("ADSL", diags)] = "control"
diags[grep("ADSL", diags)] = "adsl"
data_mx2 = data_mx2[, order(diags)]
data_mx2 = cbind(rep(NA, nrow(data_mx2)), data_mx2)
colnames(data_mx2)[1] = "DESCRIPTION"
write.table(data_mx2, file="EDTA_adsl.gct", sep="\t", quote=FALSE, row.names = TRUE)
abs_filename_dataset = "EDTA_adsl.gct"

diag.ind = colnames(data_mx2)[-1]
diag.ind[-grep("ADSL", diag.ind)] = 0
diag.ind[grep("ADSL", diag.ind)] = 1
diag.ind = as.numeric(diag.ind)
diag.ind[which(diag.ind==1)] = "D"
diag.ind[which(diag.ind==0)] = "C"
diag.ind = paste(diag.ind, collapse=" ")
# Add #num_samples 1 2, where num_samples is a numeric value equal to the nrow(data_mx2)-1
# Add #disease control
write.table(diag.ind, file="EDTA_adsl.cls", sep=" ", quote=FALSE, row.names = FALSE, col.names = FALSE)
abs_filename_classes = "EDTA_adsl.cls"

adsl_msea = stats.getMSEA_Metabolon(abs_filename_dataset, abs_filename_classes, pathway_knowledgebase = "Metabolon", output_dir = getwd(), expt_name="adsl")
adsl_msea = adsl_msea$report2[,c("MS", "SIZE", "NES", "NOM p-val", "FDR q-val")]
adsl_msea[order(adsl_msea$`FDR q-val`, decreasing = FALSE), ]

```
## Learn Partial-Correlation Disease-Specific Interaction Networks
``` {r learn-networks}
require(CTD)
require(huge)
setwd("Methods_paper/")
for (model in c("aadc", "abat", "adsl")) {
  refs = data_mx[,grep("REF", colnames(data_mx))]
  ref_fill = apply(refs, 1, function(i) sum(is.na(i))/length(i))
  maps.ind = colnames(data_mx)[grep("UDN", colnames(data_mx))]
  maps_fill = apply(data_mx[,maps.ind], 1, function(i) sum(is.na(i))/length(i))

  print(sprintf("Learning graphs for diag %s...", model))
  diag_pts = colnames(data_mx)[grep(toupper(model), colnames(data_mx))]
  # EDTA models
  fill.rate = apply(data_mx[,diag_pts], 1, function(i) sum(is.na(i))/length(i))
  ref_pts = colnames(refs)
  # Use EDTA data as reference data
  diag_data = data_mx[which(fill.rate<0.50), which(colnames(data_mx) %in% diag_pts)]
  refs2 = refs[which(rownames(refs) %in% rownames(diag_data)), ]
  diag_data = diag_data[which(rownames(diag_data) %in% rownames(refs2)),]
  
  # If user is against using surrogate profiles, then just select reference profiles and impute NAs, then learn network.
  #ind = sample(1:ncol(refs2), ncol(diag_data))
  #data_mx2 = cbind(diag_data, refs2[,ind])
  #rmThese = c()
  #for (r in 1:nrow(data_mx2)) {
  #  if (all(is.na(as.numeric(data_mx2[rownames(data_mx2)[r],  ])))) {
  #    rmThese = c(rmThese, r)
  #  } else {
  #      data_mx2[r, which(is.na(data_mx2[r, ]))] = min(na.omit(as.numeric(refs2[rownames(data_mx2)[r], ])))
  #  }
  #}
  #if (length(rmThese) > 0) { data_mx2 = data_mx2[-rmThese, ] }
  #any(is.na(data_mx2)) # should be FALSE
  #any(is.infinite(unlist(data_mx2))) # should be FALSE
  #var.met = apply(data_mx2, 1, sd)
  #if (length(which(var.met == 0)) > 0) { data_mx2 = data_mx2[-which(var.met == 0), ] }
  #rownames(data_mx2) = tolower(rownames(data_mx2))
  #data_mx2 = apply(data_mx2, c(1, 2), as.numeric)
  #dim(data_mx2)
  #inv_covmatt = huge(t(data_mx2), method="glasso")
  #inv_covmatt_select = huge.select(inv_covmatt, criterion="ebic")

  # If user okay with surrogate profiles (Recommended):
  diag_data = data.surrogateProfiles(data = diag_data, std = 1, useMnDiseaseProfile = FALSE, addHealthyControls = TRUE, ref_data = refs2)
  ref_data = data.surrogateProfiles(data = refs2, std = 1, useMnDiseaseProfile = FALSE, addHealthyControls = TRUE, ref_data = refs2)
  print(dim(diag_data))
  print(dim(ref_data))

  # Disease Network: GLASSO approach
  inv_covmatt = huge(t(diag_data), method="glasso")
  inv_covmatt_select = huge.select(inv_covmatt, criterion="stars")
  inv_covmat = as.matrix(inv_covmatt_select$icov[[which(inv_covmatt_select$lambda==inv_covmatt_select$opt.lambda)]])
  diag(inv_covmat) = 0;
  colnames(inv_covmat) = rownames(diag_data)
  ig = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
  V(ig)$name = rownames(diag_data)
  adj_mat = as.matrix(get.adjacency(ig, attr="weight"))
  print(ig)
  #write.table(adj_mat, file=sprintf("Clinical_paper/graphs/graph%s_glasso_maps.txt", toupper(model)), sep="\t", col.names=TRUE, row.names=TRUE)

  # Reference Network: GLASSO approach
  inv_covmatt = huge(t(ref_data), method="glasso", lambda = inv_covmatt_select$opt.lambda)
  inv_covmat = as.matrix(inv_covmatt$icov[[1]])
  diag(inv_covmat) = 0;
  colnames(inv_covmat) = rownames(ref_data)
  ig_ref = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
  V(ig_ref)$name = rownames(ref_data)
  adj_mat = as.matrix(get.adjacency(ig_ref, attr="weight"))
  print(ig_ref)
  #write.table(adj_mat, file=sprintf("Clinical_paper/graphs/graph%sREF_glasso_maps.txt", toupper(model)), sep="\t", col.names=TRUE, row.names=TRUE)

  rm(adj_mat, anno, diag_data, ref_data, diagnoses, hep_refs, inv_covmat, inv_covmatt, inv_covmatt_select,
     Miller2015_Heparin, nones, refs, refs2, diag_pts, fill.rate, hep_ref_fill, ind, maps_fill,
     maps.ind, ref_fill, ref_pts)
  save.image(sprintf("Clinical_paper/graphs/bg_%s_maps.RData", model))
  rm(ig, ig_ref)
}
```

``` {r prune-networks}
require(CTD)
load("Clinical_paper/graphs/bg_aadc_maps.RData")
ig_pruned = graph.naivePruning(ig, ig_ref)
adj_mat = as.matrix(get.adjacency(ig_pruned, attr="weight"))
write.table(adj_mat, file="graphAADC_glasso_maps_naive.txt", sep="\t", col.names=TRUE, row.names=TRUE)
save(ig_pruned, file="Clinical_paper/graphs/bg_aadc_maps_naive.RData")

rm(cohorts, data_mx, ig, ig_ref, ig_pruned, model)
load("Clinical_paper/graphs/bg_abat_maps.RData")
ig_pruned = graph.naivePruning(ig, ig_ref)
adj_mat = as.matrix(get.adjacency(ig_pruned, attr="weight"))
write.table(adj_mat, file="graphABAT_glasso_maps_naive.txt", sep="\t", col.names=TRUE, row.names=TRUE)
save(ig_pruned, file="Clinical_paper/graphs/bg_abat_maps_naive.RData")

rm(cohorts, data_mx, ig, ig_ref, ig_pruned, model)
load("Clinical_paper/graphs/bg_adsl_maps.RData")
ig_pruned = graph.naivePruning(ig, ig_ref)
adj_mat = as.matrix(get.adjacency(ig_pruned, attr="weight"))
write.table(adj_mat, file="graphADSL_glasso_maps_naive.txt", sep="\t", col.names=TRUE, row.names=TRUE)
save(ig_pruned, file="Clinical_paper/graphs/bg_adsl_maps_naive.RData")

```
## Interpret Patient Metabolomics Profiles using CTD and Disease-Specific Networks
``` {r ctd_multi-node}
# Run memory on all patients against pruned graphs as disease network. 
# If run on cluster, launch 1 disease model per PBS script.
# PBS script is called rrunCTD_multiNode.pbs and R script is called runCTD_multiNode.r. 

# --------------------------------- Contents of runCTD_multiNode.pbs --------------------------------- #
#     # Request 1 processors on 1 node
#     #PBS -l nodes=1:ppn=1
#     #Request x number of hours of walltime
#     #PBS -l walltime=10:00:00
#     #Request that regular output and terminal output go to the same file
#     #PBS -j oe
#     #PBS -m abe
#     module load R/3.3
#     cd metabolomics/9thCommitteeMeeting/runCTD_naive
#     model=${model}
#     echo $model
#     Rscript runCTD_multiNode.r $model "naive" > runCTD:naive_$model.out
#     rm runCTD:naive_$model.out


# --------------------------------- Contents of runCTD_multiNode.r --------------------------------- #
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]

require(R.utils)
require(CTD)
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01

#args = commandArgs(trailingOnly=TRUE)
#model=args[1]

for (model in c("aadc", "abat", "adsl")) {
  ig = loadToEnv(sprintf("../Clinical_paper/graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
  V(ig)$name = sapply(V(ig)$name, trimws)
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  G = vector(mode="list", length=length(V(ig)$name))
  names(G) = V(ig)$name
  data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name),]
  data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
  data.pvals = t(data.pvals)
  
  df = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(),
                fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), stringsAsFactors = FALSE)
  r=1
  ptBSbyK = list()
  for (p in 1:ncol(data_mx)) {
    ptID = colnames(data_mx)[p]
    print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
    diag = gsub("[[:digit:]]", "", colnames(data_mx)[p])
    S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
    perms = multiNode.getNodeRanks(names(S), G)
    ptBSbyK[[ptID]] = multiNode.getPtBSbyK(names(S), perms)
    res = mle.getEncodingLength(ptBSbyK[[ptID]], data.pvals, ptID, G)
    for (k in 1:kmx) {
      df[r, "ptID"] = colnames(data_mx)[p]
      df[r, "diag"] = diag
      df[r, "S"] = paste(names(S)[1:k], collapse="/")
      df[r, "lenS"] = k
      df[r, "optT"] = res[k, "opt.T"]
      df[r, "fishers"] = res[k, "fishers.Info"]
      df[r, "I0"] = res[k, "IS.null"]
      df[r, "IA"] = res[k, "IS.alt"]
      df[r, "d"] = res[k, "d.score"]
      r = r + 1
    }
    save(ptBSbyK, df, file=sprintf("model_%s_maps.RData", model))
  }
}


```

``` {r ctd_single-node}

setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]

require(R.utils)
require(CTD)
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01

for (model in c("aadc", "abat", "adsl")) {
  ig = loadToEnv(sprintf("nof1/graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
  V(ig)$name = sapply(V(ig)$name, trimws)
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  G = vector(mode="list", length=length(V(ig)$name))
  names(G) = V(ig)$name
  data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name),]
  data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
  data.pvals = t(data.pvals)
  
  ranks = loadToEnv(sprintf("nof1/%snaive-ranks.RData", toupper(model)))[["permutationByStartNode"]]
  ranks = lapply(ranks, function(i) tolower(i))
  names(ranks) = as.character(lapply(ranks, function(i) i[[1]][1]))
  
  df = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(),
                fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), stringsAsFactors = FALSE)
  r=1
  ptBSbyK = list()
  for (p in 1:ncol(data_mx)) {
    ptID = colnames(data_mx)[p]
    print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
    diag = gsub("[[:digit:]]", "", colnames(data_mx)[p])
    S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
    ptBSbyK[[ptID]] = singleNode.getPtBSbyK(names(S), ranks)
    res = mle.getEncodingLength(ptBSbyK[[ptID]], data.pvals, ptID, G)
    for (k in 1:kmx) {
      df[r, "ptID"] = colnames(data_mx)[p]
      df[r, "diag"] = diag
      df[r, "S"] = paste(names(S)[1:k], collapse="/")
      df[r, "lenS"] = k
      df[r, "optT"] = res[k, "opt.T"]
      df[r, "fishers"] = res[k, "fishers.Info"]
      df[r, "I0"] = res[k, "IS.null"]
      df[r, "IA"] = res[k, "IS.alt"]
      df[r, "d"] = res[k, "d.score"]
      r = r + 1
    }
    save(ptBSbyK, df, file=sprintf("ptSim/v2/single-node/model_%s_maps.RData", model))
  }
}


```



## Table 2 Single-Node vs. Multi-Node Signal in 3 Example Patients
``` {r singleNode-nof1}
#### TABLE 2, Single-Node Diffusion Encoding Algorithm ######

# Step 1: Get pre-computed single-node diffusion node ranks for all metabolites in a given disease network model.
# FILE HIERARCHY: 
#        graphs/ folder with all bg_[model]_maps_naive.RData files in it.
#        wrapper_ranks.r
#        getRanks.pbs
#        getRanksN.r
#        collate.r
#        clinical_data.RData
# DIRECTIONS: Run wrapper_ranks.r and collate.r on cluster with for each pruned disease network. Set type="naive" since we want the 
#             node ranks for the pruned disease network. type="D" is used for the raw disease network and type="REF" is used for 
#             the reference network.
Rscript wrapper_ranks.r "AADC" "naive"
Rscript wrapper_ranks.r "ABAT" "naive"
Rscript wrapper_ranks.r "ADSL" "naive"

# Step 2: Once you have the pre-computed node ranks (using single-node diffusion) from cluster, get the metabolomics evidence for each disease network context using the single-node encoding algorithm. (Table 2)
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1")
rm(list=ls())
# ABAT patient X624685, ABAT004.
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="abat"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="ABAT004")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = list()
for (i in 1:length(S)) {
  ind = which(names(G)==names(S)[i])
  ranks[[names(S)[i]]] = singleNode.getNodeRanksN(ind, G, names(S), log2(length(G)))
}
names(ranks) = names(S)
ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))]
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))

# AADC patient X624843, AADC002.
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="aadc"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="AADC002")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = list()
for (i in 1:length(S)) {
  ind = which(names(G)==names(S)[i])
  ranks[[names(S)[i]]] = singleNode.getNodeRanksN(ind, G, names(S), misses.thresh = log2(length(G)))
}
names(ranks) = names(S)
ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))]
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))

# ADSL patient X650033, ADSL003. This patient also visualized in pathway map.
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="adsl"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="ADSL003")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = list()
for (i in 1:length(S)) {
  ind = which(names(G)==names(S)[i])
  ranks[[names(S)[i]]] = singleNode.getNodeRanksN(ind, G, names(S), misses.thresh = log2(length(G)))
}
names(ranks) = names(S)
ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))]
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))


# Which metabolites are:
# RED (medication, not disease relevant), 
# GREEN (confirmed/published biomarkers),
# YELLOW (suspect relevant)
diags = colnames(data_mx)
diags[grep("UDN", diags)] = "Unknown"
diags[grep("REF", diags)] = "CNTL"
diags[grep("ABAT", diags)] = "ABAT"
diags[grep("AADC", diags)] = "AADC"
diags[grep("ADSL", diags)] = "ADSL"

pt_mets = names(S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))])
data_mx2 = data_mx[which(rownames(data_mx) %in% pt_mets),-which(diags=="Unknown")]
diags = diags[-which(diags=="Unknown")]

dff = data.frame(met=as.vector(sapply(rownames(data_mx2), function(i) rep(i, ncol(data_mx2)))), 
                 ptID = rep(colnames(data_mx2), nrow(data_mx2)),
                 zscore = as.vector(apply(data_mx2, 1, function(i) i)),
                 diags = rep(diags, nrow(data_mx2)))

ggplot(data = dff, aes(x=diags, y=zscore, fill=diags)) + geom_boxplot(size=2) + facet_wrap(~met)

```

``` {r multiNode-nof1}
#### TABLE 2, Multi-Node Diffusion Encoding Algorithm ######
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1")
### ABAT patient X624685, ABAT004. ####
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="abat"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="ABAT004")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = multiNode.getNodeRanks(names(S), G)
ptBSbyK = multiNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))]
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))
# This generates the module "blown out" for figure 8a/b/c, which I then put into illustrator to make it look nice.
mets = names(S)
e = delete.vertices(ig, v=V(ig)$name[-which(V(ig)$name %in% mets)])
e = delete.vertices(e, v=names(which(degree(e)==0)))
png("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/ABAT004_module.png")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()
svg("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/ABAT004_module.svg")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()

### AADC patient X624843, AADC002. ####
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="aadc"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="AADC002")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = multiNode.getNodeRanks(names(S), G)
ptBSbyK = multiNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))]
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))
# This generates the module "blown out" for figure 8a/b/c, which I then put into illustrator to make it look nice.
mets = names(S)
e = delete.vertices(ig, v=V(ig)$name[-which(V(ig)$name %in% mets)])
e = delete.vertices(e, v=names(which(degree(e)==0)))
png("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/AADC002_module.png")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()
svg("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/AADC002_module.svg")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()

### ADSL patient X650033, ADSL003. This patient also visualized in pathway map. ####
rm(list=ls())
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
model="adsl"
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
G = vector(mode="list", length=length(V(ig)$name))
names(G) = V(ig)$name
data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
data_mx = data_mx[-grep("x - ", rownames(data_mx)), ]
data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
data.pvals = t(data.pvals)
p = which(colnames(data_mx)=="ADSL003")
ptID = colnames(data_mx)[p]
S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
ranks = multiNode.getNodeRanks(names(S), G)
ptBSbyK = multiNode.getPtBSbyK(names(S), ranks)
res = mle.getEncodingLength(ptBSbyK, data.pvals, ptID, G)
res[which.max(res[,"d.score"]),]
sort(S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))])
2^-res[which.max(res[,"d.score"]),"d.score"]
2^-(res[which.max(res[,"d.score"]),"d.score"]-log2(nrow(res)))

# This generates the module "blown out" for figure 8a/b/c, which I then put into illustrator to make it look nice.
mets = names(S)
e = delete.vertices(ig, v=V(ig)$name[-which(V(ig)$name %in% mets)])
e = delete.vertices(e, v=names(which(degree(e)==0)))
png("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/ADSL003_module.png")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()
svg("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/ADSL003_module.svg")
plot.igraph(e, layout=layout.circle, edge.width=50*abs(E(e)$weight))
dev.off()


# Which metabolites are:
# RED (medication, not disease relevant), 
# GREEN (confirmed/published biomarkers),
# YELLOW (suspect relevant)
diags = colnames(data_mx)
diags[grep("UDN", diags)] = "Unknown"
diags[grep("REF", diags)] = "CNTL"
diags[grep("ABAT", diags)] = "ABAT"
diags[grep("AADC", diags)] = "AADC"
diags[grep("ADSL", diags)] = "ADSL"

pt_mets = names(S[names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1))])
data_mx2 = data_mx[which(rownames(data_mx) %in% pt_mets),-which(diags=="Unknown")]
diags = diags[-which(diags=="Unknown")]

dff = data.frame(met=as.vector(sapply(rownames(data_mx2), function(i) rep(i, ncol(data_mx2)))), 
                 ptID = rep(colnames(data_mx2), nrow(data_mx2)),
                 zscore = as.vector(apply(data_mx2, 1, function(i) i)),
                 diags = rep(diags, nrow(data_mx2)))

ggplot(data = dff, aes(x=diags, y=zscore, fill=diags)) + geom_boxplot(size=2) + facet_wrap(~met)


# Final Green, Yellow categories boxplot figure
data("Thistlethwaite2019")
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
rownames(data_mx)[which(rownames(data_mx)=="succinimide")] = "succinamic acid"
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
diags = colnames(data_mx)
diags[grep("UDN", diags)] = "Unknown"
diags[grep("REF", diags)] = "CNTL"
diags[grep("ABAT", diags)] = "ABAT"
diags[grep("AADC", diags)] = "AADC"
diags[grep("ADSL", diags)] = "ADSL"
pt_mets = c("3-methoxytyrosine", "2-pyrrolidinone", "succinamic acid", "n6-succinyladenosine",
            "taurodeoxycholate", "hippurate", "beta-alanine", "deoxycholate", 
            "2-methylbutyrylcarnitine (c5)", "4-guanidinobutanoate", "stearoylcarnitine", 
            "palmitoylcarnitine", "oleoylcarnitine", "laurylcarnitine", "decanoylcarnitine")
data_mx2 = data_mx[which(rownames(data_mx) %in% pt_mets),-which(diags=="Unknown")]
diags = diags[-which(diags=="Unknown")]

dff = data.frame(met=as.vector(sapply(rownames(data_mx2), function(i) rep(i, ncol(data_mx2)))), 
                 ptID = rep(colnames(data_mx2), nrow(data_mx2)),
                 zscore = as.vector(apply(data_mx2, 1, function(i) i)),
                 diags = rep(diags, nrow(data_mx2)))
svg("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/green_yellow_mets.svg", width = 15, height = 10)
ggplot(data = dff, aes(x=diags, y=zscore, fill=diags)) + geom_boxplot(size=2) + facet_wrap(~met)
dev.off()

png("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/green_yellow_mets.png", width = 15, height = 10, units="in", res=350)
ggplot(data = dff, aes(x=diags, y=zscore, fill=diags)) + geom_boxplot(size=2) + facet_wrap(~met)
dev.off()

```

## Figure 7: Illustration of CTD's specificity for AADC, ABAT, ADSL models.
``` {r multinode-model-allpts}
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
rm(list=ls())
require(R.utils)
require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
for (model in c("aadc", "adsl")) {
  ig = loadToEnv(system.file(sprintf("networks/bg_%s_maps_naive.RData", model), package="CTD"))[["ig_pruned"]]
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  G = vector(mode="list", length=length(V(ig)$name))
  names(G) = V(ig)$name
  data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
  data.pvals = t(apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE)))

  df = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(),
                fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), stringsAsFactors = FALSE)
  r=1
  ptBSbyK = list()
  for (p in 1:ncol(data_mx)) {
    ptID = colnames(data_mx)[p]
    print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
    diag = gsub("[[:digit:]]", "", colnames(data_mx)[p])
    S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
    perms = multiNode.getNodeRanks(names(S), G)
    ptBSbyK[[ptID]] = multiNode.getPtBSbyK(names(S), perms)
    res = mle.getEncodingLength(ptBSbyK[[ptID]], data.pvals, ptID, G)
    for (k in 1:kmx) {
      df[r, "ptID"] = colnames(data_mx)[p]
      df[r, "diag"] = diag
      df[r, "S"] = paste(names(S)[1:k], collapse="/")
      df[r, "lenS"] = k
      df[r, "optT"] = res[k, "opt.T"]
      df[r, "fishers"] = res[k, "fishers.Info"]
      df[r, "I0"] = res[k, "IS.null"]
      df[r, "IA"] = res[k, "IS.alt"]
      df[r, "d"] = res[k, "d.score"]
      r = r + 1
    }
  }
  save(ptBSbyK, df, file=sprintf("mn_model_%s_maps.RData", model))
}

# Figure boxplots showing CTD's specificity
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper")
# Figure 8: Plot patient ID vs. bits for each graph, for AADC, ABAT and then ADSL
require(ggplot2)
model="adsl"
load(sprintf("mn_model_%s_maps.RData", model))
df_aadc = df
pts = unique(df_aadc$ptID)
df_best = data.frame(pt=numeric(), bits=numeric(), diag=character(), stringsAsFactors = FALSE)
for (pt in 1:length(pts)) {
  pt_data = df_aadc[which(df_aadc$ptID==pts[pt]),]
  df_best[pt, "pt"] = pts[pt]
  df_best[pt, "bits"] = max(df_aadc[which(df_aadc$ptID==pts[pt]), "d"])-log2(nrow(pt_data))
  df_best[pt, "diag"] = unique(pt_data[,"diag"])
}
df_best$bits[which(df_best$bits<0)] = 0

# This generates figure 8a/b/c's graph.
png(sprintf("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/%s_bg_naive.png", model), height=1000, width=1500, res=350)
ggplot(df_best, aes(x=diag, y=bits, fill=diag)) + geom_boxplot(size=2) + geom_hline(yintercept=-log2(0.05)+log2(length(pts))) +  theme(text = element_text(size=20))
dev.off()

```

``` {r singlenode-model-allpts}
# Get metabolomics evidence using memory network walker (Table 2)
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/")
load("clinical_data.RData")
kmx=15
p0=0.1
p1=0.9
thresholdDiff=0.01
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
for (model in c("abat", "aadc", "adsl")) {
  load(sprintf("../Methods_paper/nof1/%snaive-ranks.RData", toupper(model)))
  ranks = permutationByStartNode
  ranks = lapply(ranks, function(i) tolower(i))
  f = as.character(lapply(ranks, function(i) i[[1]][1]))
  names(ranks) = f
  ig = loadToEnv(sprintf("graphs/bg_%s_maps_naive.RData", model))[["ig_pruned"]]
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  G = vector(mode="list", length=length(V(ig)$name))
  names(G) = V(ig)$name
  V(ig)$name = sapply(V(ig)$name, trimws)
  data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
  data.pvals = apply(data_mx, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
  data.pvals = t(data.pvals)

  df = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(),
                fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), stringsAsFactors = FALSE)
  r=1
  ptBSbyK = list()
  for (p in 1:ncol(data_mx)) {
    ptID = colnames(data_mx)[p]
    print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
    diag = gsub("[[:digit:]]", "", colnames(data_mx)[p])
    S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
    ptBSbyK[[ptID]] = singleNode.getPtBSbyK(names(S), ranks)
    res = mle.getEncodingLength(ptBSbyK[[ptID]], data.pvals, ptID, G)
    for (k in 1:kmx) {
      df[r, "ptID"] = colnames(data_mx)[p]
      df[r, "diag"] = diag
      df[r, "S"] = paste(names(S)[1:k], collapse="/")
      df[r, "lenS"] = k
      df[r, "optT"] = res[k, "opt.T"]
      df[r, "fishers"] = res[k, "fishers.Info"]
      df[r, "I0"] = res[k, "IS.null"]
      df[r, "IA"] = res[k, "IS.alt"]
      df[r, "d"] = res[k, "d.score"]
      r = r + 1
    }
  }
  save(ptBSbyK, df, file=sprintf("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/model_%s_maps_sn.RData", model))
}

# Figure boxplots showing CTD's specificity
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper")
# Figure 8: Plot patient ID vs. bits for each graph, for AADC, ABAT and then ADSL
require(ggplot2)
model="aadc"
load(sprintf("../Clinical_paper/runCTD/naive_pruned/model_%s_maps.RData", model))
df_aadc = df
pts = unique(df_aadc$ptID)
df_best = data.frame(pt=numeric(), bits=numeric(), diag=character(), stringsAsFactors = FALSE)
for (pt in 1:length(pts)) {
  pt_data = df_aadc[which(df_aadc$ptID==pts[pt]),]
  df_best[pt, "pt"] = pts[pt]
  df_best[pt, "bits"] = max(df_aadc[which(df_aadc$ptID==pts[pt]), "d"])-log2(15)
  df_best[pt, "diag"] = unique(pt_data[,"diag"])
}
df_best$bits[which(df_best$bits<0)] = 0
df_best[which(df_best$diag=="reference"), "diag"] = "UDN"
df_best = df_best[which(df_best$diag %in% c("aadc", "abat", "adsl", "UDN")),]

# This generates figure 8a/b/c's graph.
png(sprintf("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/nof1/%s_bg_naive.png", model), height=1000, width=1500, res=350)
ggplot(df_best, aes(x=diag, y=bits, fill=diag)) + geom_boxplot(size=2) + geom_hline(yintercept=-log2(0.05)) +  theme(text = element_text(size=20))
dev.off()

```

## CTD vs. Partial Least Squares Regression
Precision is more focused in the positive class than in the negative class, it actually measures the probability of correct detection of positive values, while FPR and TPR (ROC metrics) measure the ability to distinguish between the classes.
``` {r ctd_feature_select}
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
kmx=15
# Module Feature Select, memory
for (model in c("abat", "aadc", "adsl")) {
  load(sprintf("pls_vs_ctd/mn_model_%s_maps.RData", model))
  df_memory = data.frame(ptID=character(), m=numeric(), stringsAsFactors = FALSE)
  pts = unique(df[,"ptID"])
  pts = pts[grep(toupper(model), pts)]
  for (pt in 1:length(pts)) {
    pt_dt = df[which(df[,"ptID"]==pts[pt]),]
    df_memory[pt, "ptID"] = pts[pt]
    df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(kmx)
  }
  res = df[which(df[,"ptID"]==df_memory$ptID[which.max(df_memory$m)]),]
  
  if (model=="abat") {
    abat_module_select = unlist(strsplit(res[which.max(res[,"d"]), "S"], split="/"))
  } else if (model=="aadc") {
    aadc_module_select = unlist(strsplit(res[which.max(res[,"d"]), "S"], split="/"))
  } else {
    adsl_module_select = unlist(strsplit(res[which.max(res[,"d"]), "S"], split="/"))
  }
}
```

``` {r pathway-vs-ctd-global}
imputeMissingValues = function(data, ref) {
  data = data[which(rownames(data) %in% rownames(ref)),]
  ref = ref[which(rownames(ref) %in% rownames(data)),]
  data = data[sort(rownames(data)),]
  ref = ref[sort(rownames(ref)),]
  
  imputed.data = data
  for (met in 1:nrow(ref)) {
    rowData = ref[met,]
    if (any(is.na(rowData))) {
      rowData = as.numeric(rowData[-which(is.na(rowData))])
    } else {
      rowData = as.numeric(rowData)
    }
    # Impute using uniform random variable, where a = 0.99*observed minimum, and b = observed minimum
    min_row = min(rowData)
    if (min_row<0) {
      min_row = -1*min_row
      imputed.data[met, is.na(data[met,])] = tryCatch(-1*runif(sum(is.na(data[met,])), min = 0.99*min_row, max= min_row), 
                                                      error = function(e) e, warning=function(w) print(sprintf("%s: met%d", w, met)))
    } else {
      imputed.data[met, is.na(data[met,])] = tryCatch(runif(sum(is.na(data[met,])), min = 0.99*min(rowData), max= min(rowData)), 
                                                      error = function(e) e, warning=function(w) print(sprintf("%s: met%d", w, met)))
    }
  }
  return(imputed.data)
}

# CTD Global discrimination: CTD disease specific models call "yes" or "no" based on significance of patient's top metabolite perturbations.
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
require(CTD)
require(pls)
require(pROC)
kmx=15
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
data_mx = data_mx[,-grep("UDN", colnames(data_mx))]
ref_data = data_mx[,grep("REF", colnames(data_mx))]
module_select = list()
module_select[["aadc"]] = aadc_module_select
module_select[["abat"]] = abat_module_select
module_select[["adsl"]] = adsl_module_select
for (model in c("aadc", "abat", "adsl")) {
  # ABAT fill rate
  abat_data = data_mx[, grep("ABAT", colnames(data_mx))]
  abat_fill = apply(abat_data, 1, function(i) sum(is.na(i))/length(i))
  # AADC fill rate
  aadc_data = data_mx[, grep("AADC", colnames(data_mx))]
  aadc_fill = apply(aadc_data, 1, function(i) sum(is.na(i))/length(i))
  # ADSL fill rate
  adsl_data = data_mx[, grep("ADSL", colnames(data_mx))]
  adsl_fill = apply(adsl_data, 1, function(i) sum(is.na(i))/length(i))
  df_fillrate = data_mx[intersect(intersect(which(abat_fill<0.50), which(aadc_fill<0.50)), which(adsl_fill<0.50)), ]
  #dim(df_fillrate)  
  load(sprintf("pls_vs_ctd/mn_model_%s_maps.RData", model))
  df_memory = data.frame(ptID=character(), m=numeric(), stringsAsFactors = FALSE)
  pts = unique(df[,"ptID"])
  for (pt in 1:length(pts)) {
    pt_dt = df[which(df[,"ptID"]==pts[pt]),]
    df_memory[pt, "ptID"] = pts[pt]
    df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(kmx)
  }
  df_memory = df_memory[which(df_memory[,"ptID"] %in% colnames(df_fillrate)),]
  
  # PLS model w/ variance based feature selection
  df_mn = apply(df_fillrate[,grep(toupper(model), colnames(df_fillrate))], 1, function(i) mean(na.omit(i)))
  df2 = as.data.frame(df_fillrate[order(abs(df_mn), decreasing = TRUE)[1:length(module_select[[model]])], ])
  # Impute missing values
  if (any(is.na(df2))) { df2 = imputeMissingValues(df2, ref_data) }
  # Get diagnostic labels
  diags = colnames(df2)
  diags[-grep(toupper(model), diags)] = 0
  diags[grep(toupper(model), diags)] = 1
  df2 = rbind(df_memory$m, df2)
  rownames(df2)[1] = "metabolomics_evidence"
  df2 = rbind(diags, df2)
  rownames(df2)[1] = "diag"
  df2 = apply(df2, c(1,2), as.numeric)

  # PLS model w/ CTD feature selection
  df2_ctd = df_fillrate[which(rownames(df_fillrate) %in% module_select[[model]]), ]
  
  # Impute missing values using mice R package
  if (any(is.na(df2_ctd))) { df2_ctd = imputeMissingValues(df2_ctd, ref_data) }
  # Get diagnostic labels
  diags = colnames(df2_ctd)
  diags[-grep(toupper(model), diags)] = 0
  diags[grep(toupper(model), diags)] = 1
  df2_ctd = rbind(df_memory$m, df2_ctd)
  rownames(df2_ctd)[1] = "metabolomics_evidence"
  df2_ctd = rbind(diags, df2_ctd)
  rownames(df2_ctd)[1] = "diag"
  df2_ctd = apply(df2_ctd, c(1,2), as.numeric)
  
  dff_model = data.frame(pls_var=numeric(), pls_ctd=numeric(), 
                         pls_var_ctd=numeric(), pls_ctd_ctd=numeric(), 
                         pls_x_ctd=numeric(), stringsAsFactors = FALSE)
  for (it in 1:ncol(df2)) {
    isTrain = c(1:ncol(df2))[-it]
    # Variance-based feature selection: Train model
    df2_2 = df2[-which(rownames(df2)=="metabolomics_evidence"), ]
    model_res = plsr(diag~., data = as.data.frame(t(df2_2[,isTrain])))
    tst_data = df2_2[-1,-isTrain]
    model_tst =  predict(model_res, ncomp=model_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_var"] = model_tst

    # CTD feature selection: Train model
    df2_ctd_2 = df2_ctd[-which(rownames(df2_ctd)=="metabolomics_evidence"), ]
    ctd_res = plsr(diag~., data = as.data.frame(t(df2_ctd_2[,isTrain])))
    tst_data = df2_ctd_2[-1,-isTrain]
    ctd_tst = predict(ctd_res, ncomp=ctd_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_ctd"] = ctd_tst
    
    # Variance-based feature selection, plus CTD as covariate
    model_res = plsr(diag~., data = as.data.frame(t(df2[,isTrain])))
    tst_data = df2[-1,-isTrain]
    model_tst =  predict(model_res, ncomp=model_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_var_ctd"] = model_tst

    # CTD feature selection, plus CTD as covariate
    ctd_res = plsr(diag~., data = as.data.frame(t(df2_ctd[,isTrain])))
    tst_data = df2_ctd[-1,-isTrain]
    ctd_tst = predict(ctd_res, ncomp=ctd_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_ctd_ctd"] = ctd_tst
    
    # No features, just CTD as only covariate
    #xx_tmp = df2_ctd[-(3:nrow(df2_ctd)),]
    #x_res = plsr(diag~., data = as.data.frame(t(xx_tmp[,isTrain])))
    #tst_data = xx_tmp[-1,-isTrain]
    #names(tst_data) = "metabolomics_evidence"
    #x_tst = predict(x_res, ncomp=x_res$ncomp, newdata=as.data.frame(t(tst_data)))
    #dff_model[it, "pls_x_ctd"] = ctd_tst
  }
  
  if (model=="abat") {
    print("For ABAT model...")
  } else if (model=="aadc") {
    print("For AADC model...")
  } else {
    print("For ADSL model...")
  }
  
  # Calculate AUC using pROC, since you cannot calculate directly with TP, TN, FP, FN
  plsvar_auc = roc(diags, dff_model[,"pls_var"])
  plsctd_auc = roc(diags, dff_model[,"pls_ctd"])
  plsvar_ctd_auc = roc(diags, dff_model[,"pls_var_ctd"])
  plsctd_ctd_auc = roc(diags, dff_model[,"pls_ctd_ctd"])
  ctd_auc = roc(diags, dff_model[,"pls_x_ctd"])
  m = df_memory$m-min(df_memory$m)
  ctd_auc = roc(diags, m/max(m))

  print(sprintf("PLS.var     AUC = %.3f", plsvar_auc$auc))
  print(sprintf("PLS.ctd     AUC = %.3f", plsctd_auc$auc))
  print(sprintf("PLS.var+CTD AUC = %.3f", plsvar_ctd_auc$auc))
  print(sprintf("PLS.ctd+CTD AUC = %.3f", plsctd_ctd_auc$auc))
  print(sprintf("CTD AUC = %.3f", ctd_auc$auc))
  
  plsvar_auc2 = coords(plsvar_auc, 0.5, ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsctd_auc2 = coords(plsctd_auc, 0.5, ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsvar_ctd_auc2 = coords(plsvar_ctd_auc, 0.5, ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsctd_ctd_auc2 = coords(plsctd_ctd_auc, 0.5, ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  ctd_auc2 = coords(ctd_auc, 0.5, ret=c("threshold", "specificity", "accuracy", "precision", "recall"))

  print(plsvar_auc2)
  print(plsctd_auc2)
  print(plsvar_ctd_auc2)
  print(plsctd_ctd_auc2)
  print(ctd_auc2)
  
  plsvar_auc2 = coords(plsvar_auc, "best", ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsctd_auc2 = coords(plsctd_auc, "best", ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsvar_ctd_auc2 = coords(plsvar_ctd_auc, "best", ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  plsctd_ctd_auc2 = coords(plsctd_ctd_auc, "best", ret=c("threshold", "specificity", "accuracy", "precision", "recall"))
  ctd_auc2 = coords(ctd_auc, "best", ret=c("threshold", "specificity", "accuracy", "precision", "recall"))

  print(plsvar_auc2)
  print(plsctd_auc2)
  print(plsvar_ctd_auc2)
  print(plsctd_ctd_auc2)
  print(ctd_auc2)
  
  # Now calculate precision manually because we don't trust pROC
  scores_model = list()
  m = df_memory$m-min(df_memory$m)
  scores_model[["ctd"]] = m/max(m)
  scores_model[["plsvar"]] = dff_model[,"pls_var"]
  scores_model[["plsctd"]] = dff_model[,"pls_ctd"]
  scores_model[["plsvar.ctd"]] = dff_model[,"pls_var_ctd"]
  scores_model[["plsctd.ctd"]] = dff_model[,"pls_ctd_ctd"]
  diags = as.numeric(diags)
  dff = data.frame(model=character(), precision=numeric(), recall=numeric(), specificity=numeric(), stringsAsFactors = FALSE)
  r=1
  for (mdl in c("ctd", "plsvar", "plsctd", "plsvar.ctd", "plsctd.ctd")) {
    for (thresh in seq(0, 1, 0.001)) {
      tp = length(intersect(which(scores_model[[mdl]]>=thresh), which(diags==1)))
      fp = length(intersect(which(scores_model[[mdl]]>=thresh), which(diags==0)))
      fn = length(intersect(which(scores_model[[mdl]]<thresh), which(diags==1)))
      tn = length(intersect(which(scores_model[[mdl]]<thresh), which(diags==0)))
      dff[r, "model"] = mdl
      dff[r, "thresh"] = thresh
      dff[r, "precision"] = tp/(tp+fp)
      dff[r, "recall"] = tp/(tp+fn)
      dff[r, "specificity"] = 1-fp/(fp+tn)
      r = r + 1
    }
  }
  #ggplot(dff[which(dff$model=="plsvar"),]) + geom_point(aes(x=thresh, y=precision)) + ggtitle("PLSvar")
  #ggplot(dff[which(dff$model=="plsctd"),]) + geom_point(aes(x=thresh, y=precision)) + ggtitle("PLSctd")
  #ggplot(dff[which(dff$model=="plsvar.ctd"),]) + geom_point(aes(x=thresh, y=precision)) + ggtitle("PLSvar.ctd")
  #ggplot(dff[which(dff$model=="plsctd.ctd"),]) + geom_point(aes(x=thresh, y=precision)) + ggtitle("PLSctd.ctd")
  #ggplot(dff[which(dff$model=="ctd"),]) + geom_point(aes(x=thresh, y=precision)) + ggtitle("CTD")
  
  print(sprintf("CTD Precision @0.5 = %.3f", dff[which(dff$thresh==0.5),"precision"][1]))
  print(sprintf("PLS.var     Precision @0.5 = %.3f", dff[which(dff$thresh==0.5),"precision"][2]))
  print(sprintf("PLS.ctd     Precision @0.5 = %.3f", dff[which(dff$thresh==0.5),"precision"][3]))
  print(sprintf("PLS.var+CTD Precision @0.5 = %.3f", dff[which(dff$thresh==0.5),"precision"][4]))
  print(sprintf("PLS.ctd+CTD Precision @0.5 = %.3f", dff[which(dff$thresh==0.5),"precision"][5]))

  
  # Visualize ROCs
  df_vis = data.frame(specificity=c(1-plsvar_auc$specificities, 1-plsctd_auc$specificities, 
                                    1-plsvar_ctd_auc$specificities, 1-ctd_auc$specificities),
                      sensitivity=c(plsvar_auc$sensitivities, plsctd_auc$sensitivities, 
                                    plsvar_ctd_auc$sensitivities, ctd_auc$sensitivities),
                      method=c(rep("PLSvar", length(plsvar_auc$specificities)), 
                               rep("PLSctd", length(plsctd_auc$specificities)),
                               rep("PLSvar-CTD", length(plsvar_ctd_auc$specificities)),
                               rep("CTD", length(ctd_auc$specificities))))
  png(sprintf("pls_vs_ctd/ctd_pls_%s.png", model))
  ggplot(df_vis) + geom_line(aes(x=specificity, y=sensitivity, colour=method), size=3) +
    ggtitle(sprintf("ROC for Diagnosis of %s deficiency\nwith CTD as a Covariate and\nFeature Selection Method", toupper(model)))
  dev.off()
}

```

```{r ctd-model}
# CTD models
rm(list=ls())
require(pROC)
require(R.utils)
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/runCTD/naive_pruned/")
kmx=15
load("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/clinical_data.RData")
maps.ind = colnames(data_mx)[grep("ID_", colnames(data_mx))]
maps.ind = maps.ind[which(sapply(maps.ind, function(i) length(unlist(strsplit(i, split=""))))>6)]
for (model in c("abat", "aadc", "adsl")) {
  data_mx = data_mx[, which(colnames(data_mx) %in% c(maps.ind, cohorts$abat[-7], cohorts$aadc, cohorts$adsl))]
  load(sprintf("model_%s_maps.RData", model))
  df = df[which(df$ptID %in% colnames(data_mx)),]
  df_memory = data.frame(ptID=character(), m=numeric(), stringsAsFactors = FALSE)
  pts = unique(df[,"ptID"])
  for (pt in 1:ncol(data_mx)) {
    pt_dt = df[which(df[,"ptID"]==pts[pt]),]
    df_memory[pt, "ptID"] = pts[pt]
    df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(kmx)
  }
  
  # ROC using memoryless vs. memory predictions
  diags = colnames(data_mx)
  diags[which(!(diags %in% cohorts[[model]]))] = 0
  diags[which(diags %in% cohorts[[model]])] = 1
  if (model=="abat") {
    diags[which(colnames(data_mx)=="ID_595481")] = 1
  } else if (model=="aadc") {
    diags[which(colnames(data_mx)=="ID_602464")] = 1
    diags[which(colnames(data_mx)=="ID_672307")] = 1
  }
  #model_auc_memoryless = roc(diags, df_memoryless$m)
  model_auc_memory = roc(diags, df_memory$m)

  if (model=="abat") {
    #print(sprintf("For ABAT memoryless model, AUC = %.3f", as.numeric(model_auc_memoryless$auc)))
    print(sprintf("For ABAT memory model, AUC = %.3f", as.numeric(model_auc_memory$auc)))
  } else if (model=="aadc") {
    #print(sprintf("For AADC memoryless model, AUC = %.3f", as.numeric(model_auc_memoryless$auc)))
    print(sprintf("For AADC memory model, AUC = %.3f", as.numeric(model_auc_memory$auc)))
  } else {
    #print(sprintf("For ADSL memoryless model, AUC = %.3f", as.numeric(model_auc_memoryless$auc)))
    print(sprintf("For ADSL memory model, AUC = %.3f", as.numeric(model_auc_memory$auc)))
  }
}


```


## CTD Similarity and Naive Distance Metrics Compare ------------------------------------------
```{r udn_matches_both_encodings}
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/")
#### Multi-node Bonferroni corrected matches ####
load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "adsl"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
adsl_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
adsl_pt_sig2 = adsl_pt_sig[grep("UDN", adsl_pt_sig)]
adsl_bm_df = df_memory[which(df_memory$ptID %in% adsl_pt_sig2),]
dim(adsl_bm_df)
adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S),]

load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "aadc"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
aadc_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
aadc_pt_sig2 = aadc_pt_sig[grep("UDN", aadc_pt_sig)]
aadc_bm_df = df_memory[which(df_memory$ptID %in% aadc_pt_sig2),]
dim(aadc_bm_df)
#aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S),]

load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "abat"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
abat_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
abat_pt_sig2 = abat_pt_sig[grep("UDN", abat_pt_sig)]
abat_bm_df = df_memory[which(df_memory$ptID %in% abat_pt_sig2),]
dim(abat_bm_df)
#abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S),]

udns_matches = list()
udns_matches[["aadc"]] = aadc_pt_sig
udns_matches[["abat"]] = abat_pt_sig
udns_matches[["adsl"]] = adsl_pt_sig
udns_matches[["bm"]] = unique(c(adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S), "ptID"],
                                aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S), "ptID"],
                                abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S), "ptID"]))
save(udns_matches, file="mn_udns_matches.RData")

#### Multi-node raw matches ####
load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "adsl"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
adsl_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
adsl_pt_sig2 = adsl_pt_sig[grep("UDN", adsl_pt_sig)]
adsl_bm_df = df_memory[which(df_memory$ptID %in% adsl_pt_sig2),]
adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S),]


load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "aadc"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
aadc_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
aadc_pt_sig2 = aadc_pt_sig[grep("UDN", aadc_pt_sig)]
aadc_bm_df = df_memory[which(df_memory$ptID %in% aadc_pt_sig2),]
aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S),]

load(sprintf("ptSim/v2/mn_model_%s_maps.RData", "abat"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
abat_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
abat_pt_sig2 = abat_pt_sig[grep("UDN", abat_pt_sig)]
abat_bm_df = df_memory[which(df_memory$ptID %in% abat_pt_sig2),]
abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S),]

udns_matches = list()
udns_matches[["aadc"]] = aadc_pt_sig
udns_matches[["abat"]] = abat_pt_sig
udns_matches[["adsl"]] = adsl_pt_sig
udns_matches[["bm"]] = unique(c(adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S), "ptID"],
                                aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S), "ptID"],
                                abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S), "ptID"]))
save(udns_matches, file="ptSim/v2/mnRAW_udns_matches.RData")

abat_bm_df[which(abat_bm_df$ptID %in% udns_matches$bm),]
aadc_bm_df[which(aadc_bm_df$ptID %in% udns_matches$bm),]
adsl_bm_df[which(adsl_bm_df$ptID %in% udns_matches$bm),]

#### Single-node UDN matches, Bonferroni corrected ####
load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "adsl"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
adsl_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
adsl_pt_sig2 = adsl_pt_sig[grep("UDN", adsl_pt_sig)]
adsl_bm_df = df_memory[which(df_memory$ptID %in% adsl_pt_sig2),]
dim(adsl_bm_df)
adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S),]


load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "aadc"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
aadc_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
aadc_pt_sig2 = aadc_pt_sig[grep("UDN", aadc_pt_sig)]
aadc_bm_df = df_memory[which(df_memory$ptID %in% aadc_pt_sig2),]
dim(aadc_bm_df)
aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S),]

load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "abat"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))-log2(length(pts))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
abat_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
abat_pt_sig2 = abat_pt_sig[grep("UDN", abat_pt_sig)]
abat_bm_df = df_memory[which(df_memory$ptID %in% abat_pt_sig2),]
dim(abat_bm_df)
abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S),]

udns_matches = list()
udns_matches[["aadc"]] = aadc_pt_sig
udns_matches[["abat"]] = abat_pt_sig
udns_matches[["adsl"]] = adsl_pt_sig
# These are the 11 UDN patients in the CTD patient similarity section of the paper - 3 of which are confirmed AADC/ABAT/or ADSL cases, 8 of which are not.
udns_matches[["bm"]] = unique(c(adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S), "ptID"],
                                aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S), "ptID"],
                                abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S), "ptID"]))
save(udns_matches, file="ptSim/v2/single-node/sn_udns_matches.RData")

abat_bm_df[which(abat_bm_df$ptID %in% udns_matches$bm),]
aadc_bm_df[which(aadc_bm_df$ptID %in% udns_matches$bm),]
adsl_bm_df[which(adsl_bm_df$ptID %in% udns_matches$bm),]


#### Single-node raw matches #### 
load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "adsl"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
adsl_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
adsl_pt_sig2 = adsl_pt_sig[grep("UDN", adsl_pt_sig)]
adsl_bm_df = df_memory[which(df_memory$ptID %in% adsl_pt_sig2),]
adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S),]


load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "aadc"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
aadc_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
aadc_pt_sig2 = aadc_pt_sig[grep("UDN", aadc_pt_sig)]
aadc_bm_df = df_memory[which(df_memory$ptID %in% aadc_pt_sig2),]
aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S),]

load(sprintf("ptSim/v2/single-node/model_%s_maps.RData", "abat"))
df_memory = data.frame(ptID=character(), m=numeric(), S=character(), stringsAsFactors = FALSE)
pts = unique(df[,"ptID"])
for (pt in 1:length(pts)) {
  pt_dt = df[which(df[,"ptID"]==pts[pt]),]
  df_memory[pt, "ptID"] = pts[pt]
  df_memory[pt, "m"] = pt_dt[which.max(pt_dt[,"d"]), "d"]-log2(nrow(pt_dt))
  df_memory[pt, "S"] = pt_dt[which.max(pt_dt[,"d"]), "S"]
}
abat_pt_sig = df_memory[which(df_memory$m>4.32), "ptID"]
abat_pt_sig2 = abat_pt_sig[grep("UDN", abat_pt_sig)]
abat_bm_df = df_memory[which(df_memory$ptID %in% abat_pt_sig2),]
abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S),]

udns_matches = list()
udns_matches[["aadc"]] = aadc_pt_sig
udns_matches[["abat"]] = abat_pt_sig
udns_matches[["adsl"]] = adsl_pt_sig
# These are the 11 UDN patients in the CTD patient similarity section of the paper - 3 of which are confirmed AADC/ABAT/or ADSL cases, 8 of which are not.
udns_matches[["bm"]] = unique(c(adsl_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", adsl_bm_df$S), "ptID"],
                                aadc_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", aadc_bm_df$S), "ptID"],
                                abat_bm_df[grep("succinimide|2-pyrrolidinone|n6-succinyladenosine|3-methoxytyrosine", abat_bm_df$S), "ptID"]))
save(udns_matches, file="ptSim/v2/single-node/snRAW_udns_matches.RData")

abat_bm_df[which(abat_bm_df$ptID %in% udns_matches$bm),]
aadc_bm_df[which(aadc_bm_df$ptID %in% udns_matches$bm),]
adsl_bm_df[which(adsl_bm_df$ptID %in% udns_matches$bm),]



```

``` {r single-node_ptSim}
rm(list=ls())
require(CTD)
require(R.utils)
kmx=30
p0=0.1
p1=0.9
thresholdDiff=0.01
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/single-node")
load("snRAW_udns_matches.RData")
sn_udn_bm = udns_matches$bm
refs_no_hits = c(udns_matches$aadc[grep("REF", udns_matches$aadc)],
                 udns_matches$abat[grep("REF", udns_matches$abat)],
                 udns_matches$adsl[grep("REF", udns_matches$adsl)])
load("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/mnRAW_udns_matches.RData")
mn_udn_bm = udns_matches$bm
udn_bm = unique(c(sn_udn_bm, mn_udn_bm))
refs_no_hits = c(refs_no_hits, 
                 udns_matches$aadc[grep("REF", udns_matches$aadc)],
                 udns_matches$abat[grep("REF", udns_matches$abat)],
                 udns_matches$adsl[grep("REF", udns_matches$adsl)])
refs_no_hits = unique(refs_no_hits)
load("sn_udns_matches.RData")
sn_udn_bm = udns_matches$bm
load("../mn_udns_matches.RData")
mn_udn_bm = udns_matches$bm
udn_bm = unique(c(sn_udn_bm, mn_udn_bm))
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[, c(grep("AADC|ABAT|ADSL", colnames(data_mx)), 
                      grep("REF", colnames(data_mx)), 
                      which(colnames(data_mx) %in% udn_bm))]
data_mx = data_mx[, -which(colnames(data_mx) %in% refs_no_hits)]
for (model in c("abat", "aadc", "adsl")) {
  ig = loadToEnv(system.file(sprintf("networks/bg_%s_maps_naive.RData", model), package="CTD"))[["ig_pruned"]]
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  data_mx2 = data_mx[which(rownames(data_mx) %in% V(ig)$name),]
  data_mx.pvals = apply(data_mx2, c(1,2), function(i) 2*pnorm(abs(i), lower.tail = FALSE))
  ranks = loadToEnv(sprintf("%snaive-ranks.RData", toupper(model)))[["permutationByStartNode"]]
  ranks = lapply(ranks, function(i) tolower(i))
  names(ranks) = as.character(lapply(ranks, function(i) i[[1]][1]))
   
  res_all = list()
  t = list(ncd=matrix(NA, nrow=ncol(data_mx2), ncol=ncol(data_mx2)), jacdir=matrix(NA, nrow=ncol(data_mx2), ncol=ncol(data_mx2)))
  rownames(t$ncd) = colnames(data_mx2)
  colnames(t$ncd) = colnames(data_mx2)
  rownames(t$jacdir) = colnames(data_mx2)
  colnames(t$jacdir) = colnames(data_mx2)
  for (i in 1:kmx) { res_all[[i]] = t }
  for (pt in 1:(ncol(data_mx2)-1)) {
    print(pt)
    ptID = colnames(data_mx2)[pt]
    S = data_mx2[order(abs(data_mx2[,ptID]), decreasing = TRUE), ptID][1:kmx]
    p1.ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
    for (pt2 in (pt+1):ncol(data_mx2)) {
      print(pt2)
      ptID2 = colnames(data_mx2)[pt2]
      S = data_mx2[order(abs(data_mx2[,ptID2]), decreasing = TRUE), ptID2][1:kmx]
      p2.ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
      tmp = mle.getPtSim(p1.ptBSbyK, ptID, p2.ptBSbyK, ptID2, data_mx2, ranks)
      for (k in 1:kmx) {
        res_all[[k]]$ncd[ptID, ptID2] = tmp$NCD[k]
        res_all[[k]]$jacdir[ptID, ptID2] = tmp$dirSim[k]
        res_all[[k]]$ncd[ptID2, ptID] = tmp$NCD[k]
        res_all[[k]]$jacdir[ptID2, ptID] = tmp$dirSim[k]
      }
    }
  }
  save.image(sprintf("sn_ptSim_%s.RData", model))
  # Normalize rows by max value size k
  for (k in 1:kmx) {
    diag(res_all[[k]]$ncd) = 0
    res_all[[k]]$ncd = res_all[[k]]$ncd/max(na.omit(res_all[[k]]$ncd))
  }
  print(lapply(res_all, function(i) max(i$ncd))) # should be 1 for all k
  save.image(sprintf("sn_ptSim_%s_norm.RData", model))
}

#### CTDsim (NCD+Jaccard) ####
# For all 3 similarity matrices (for models GABA-T, AADC and ADSL), take the min patient distance for each k, 
# and then across k, for each pairwise patient comparison. You will end up with one similarity matrix.
rm(list=ls())
require(R.utils)
require(CTD)
require(plotly)
require(processx)

total_dist_centroids = c()
mean_acc = c()
mean_prec = c()
r = 1
for (alpha in c(1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0)) {
  print(sprintf("CTDsim for alpha = %.2f...", alpha))
  setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/single-node")
  res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "abat"))[["res_all"]]
  res_tmp = lapply(res_all, function(i) i$ncd)
  res_tmp2 = lapply(res_all, function(i) i$jac)
  res_abat = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
  diag(res_abat) = 0
  
  res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "aadc"))[["res_all"]]
  res_tmp = lapply(res_all, function(i) i$ncd)
  res_tmp2 = lapply(res_all, function(i) i$jac)
  res_aadc = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
  diag(res_aadc) = 0
  
  res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "adsl"))[["res_all"]]
  res_tmp = lapply(res_all, function(i) i$ncd)
  res_tmp2 = lapply(res_all, function(i) i$jac)
  res_adsl = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
  diag(res_adsl) = 0
  
  res_overall = mle.getMinPtDistance(list(res_abat, res_aadc, res_adsl))
  colnames(res_overall) = colnames(res_all[[1]]$ncd)
  res_overall[which(res_overall<0)] = 0
  res_overall = res_overall/max(res_overall)
  
  diags = colnames(res_all[[1]]$ncd)
  diags = gsub("[[:digit:]]", "", diags)
  
  ctd_p = plot.mdsSim(res_overall, diags, 2, NULL)
  #ctd_p = plot.mdsSim(res_overall, diags, 3, NULL)
  orca(ctd_p, sprintf("ncd_v2_%d.png", 100*alpha))
  
  # CTD Kmeans K=3
  aadc.centroid = apply(res_overall[which(diags=="AADC"),], 2, mean)
  abat.centroid = apply(res_overall[which(diags=="ABAT"),], 2, mean)
  adsl.centroid = apply(res_overall[which(diags=="ADSL"),], 2, mean)
  negCntl.centroid = apply(res_overall[which(diags=="REF"),], 2, mean)
  kmns = kmeans(res_overall, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
  df = cbind(as.numeric(kmns$cluster), diags, colnames(res_overall))
  colnames(df) = c("cluster.num", "diag", "ptID")
  c1 = df[which(df[,1]=="1"), "diag"]
  if (length(which(c1=="UDN"))>0) { c1 = c1[-which(c1=="UDN")] }
  c2 = df[which(df[,1]=="2"), "diag"]
  if (length(which(c2=="UDN"))>0) { c2 = c2[-which(c2=="UDN")] }
  c3 = df[which(df[,1]=="3"), "diag"]
  if (length(which(c3=="UDN"))>0) { c3 = c3[-which(c3=="UDN")] }
  c4 = df[which(df[,1]=="4"), "diag"]
  if (length(which(c4=="UDN"))>0) { c4 = c4[-which(c4=="UDN")] }
  
  tp = length(which(c1=="AADC")) 
  tn = length(c(which(c2!="AADC"), which(c3!="AADC"), which(c4!="AADC")))
  fp = length(c(which(c2=="AADC"), which(c3=="AADC"), which(c4=="AADC")))
  c1_acc = (tp+tn)/length(c(c1, c2, c3, c4))
  c1_prec = tp/(fp+tp)
  tp = length(which(c2=="ABAT")) 
  tn = length(c(which(c1!="ABAT"), which(c3!="ABAT"), which(c4!="ABAT")))
  fp = length(c(which(c1=="ABAT"), which(c3=="ABAT"), which(c4=="ABAT")))
  c2_acc = (tp+tn)/length(c(c1, c2, c3, c4))
  c2_prec = tp/(fp+tp)
  tp = length(which(c3=="ADSL")) 
  tn = length(c(which(c1!="ADSL"), which(c2!="ADSL"), which(c4!="ADSL")))
  fp = length(c(which(c1=="ADSL"), which(c2=="ADSL"), which(c4=="ADSL")))
  c3_acc = (tp+tn)/length(c(c1, c2, c3, c4))
  c3_prec = tp/(fp+tp)
  tp = length(which(c4=="REF")) 
  tn = length(c(which(c1!="REF"), which(c2!="REF"), which(c3!="REF")))
  fp = length(c(which(c1=="REF"), which(c2=="REF"), which(c3=="REF")))
  c4_acc = (tp+tn)/length(c(c1, c2, c3, c4))
  c4_prec = tp/(fp+tp)
  
  total_dist_centroids[r] = sum(dist(rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid)))
  mean_acc[r] = mean(c(c1_acc, c2_acc, c3_acc, c4_acc))
  mean_prec[r] = mean(c(c1_prec, c2_prec, c3_prec, c4_prec))
  r = r + 1
}


dff = data.frame(alpha=seq(1, 0, -0.1), centroids = total_dist_centroids,
                 acc = mean_acc, prec = mean_prec)
png("alpha_select.png", width = 4, height = 2, units = "in", res=350)
ggplot(dff) + 
  geom_point(aes(x=alpha, y=mean_acc, colour="Accuracy"), size=3) + 
  geom_line(aes(x=alpha, y=mean_acc, colour="Accuracy")) +
  geom_point(aes(x=alpha, y=mean_prec, colour="Precision"), size=3) + 
  geom_line(aes(x=alpha, y=mean_prec, colour="Precision"))
dev.off()


#### PtSim Blowouts ####
alpha=0.4
print(sprintf("CTDsim for alpha = %.2f...", alpha))
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/single-node")
res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "abat"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_abat = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_abat) = 0

res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "aadc"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_aadc = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_aadc) = 0

res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "adsl"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_adsl = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_adsl) = 0

res_overall = mle.getMinPtDistance(list(res_abat, res_aadc, res_adsl))
colnames(res_overall) = colnames(res_all[[1]]$ncd)
res_overall[which(res_overall<0)] = 0
res_overall = res_overall/max(res_overall)

diags = colnames(res_all[[1]]$ncd)
diags = gsub("[[:digit:]]", "", diags)

# CTD Kmeans K=4
aadc.centroid = apply(res_overall[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(res_overall[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(res_overall[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(res_overall[which(diags=="REF"),], 2, mean)
kmns = kmeans(res_overall, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(res_overall))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
c2 = df[which(df[,1]=="2"), "diag"]
c3 = df[which(df[,1]=="3"), "diag"]
c4 = df[which(df[,1]=="4"), "diag"]

ig_pruned = list()
ig_pruned$abat = loadToEnv("../graphs/bg_abat_maps_naive.RData")[["ig_pruned"]]
ig_pruned$aadc = loadToEnv("../graphs/bg_aadc_maps_naive.RData")[["ig_pruned"]]
ig_pruned$adsl = loadToEnv("../graphs/bg_adsl_maps_naive.RData")[["ig_pruned"]]
c1 = mle.blowoutSim(res_overall, data_mx, df[which(df[,1]=="1"),"ptID"], ig_pruned, 15)
c2 = mle.blowoutSim(res_overall, data_mx, df[which(df[,1]=="2"),"ptID"], ig_pruned, 15)
c3 = mle.blowoutSim(res_overall, data_mx, df[which(df[,1]=="3"),"ptID"], ig_pruned, 15)

#741F89 hex color for edges
png("c1_module.png")
plot.igraph(c1, layout=layout.circle, edge.width=50*abs(E(c1)$weight), edge.color="#741F89")
dev.off()
svg("c1_module.svg")
plot.igraph(c1, layout=layout.circle, edge.width=1+50*abs(E(c1)$weight), edge.color="#741F89")
dev.off()
png("c2_module.png")
plot.igraph(c2, layout=layout.circle, edge.width=1+50*abs(E(c2)$weight), edge.color="#741F89")
dev.off()
svg("c2_module.svg")
plot.igraph(c2, layout=layout.circle, edge.width=1+50*abs(E(c2)$weight), edge.color="#741F89")
dev.off()
png("c3_module.png")
#plot.igraph(c3, layout=layout.circle, edge.width=50*abs(E(c3)$weight), edge.color="#741F89")
plot.igraph(c3, layout=layout.circle)
dev.off()
svg("c3_module.svg")
#plot.igraph(c3, layout=layout.circle, edge.width=50*abs(E(c3)$weight), edge.color="#741F89")
plot.igraph(c3, layout=layout.circle)
dev.off()


data_mx[c("1-methylimidazoleacetate", "myristoylcarnitine", "2-pyrrolidinone", "myristoleoylcarnitine"), "UDN029"]
data_mx[c("sebacate (decanedioate)", "2-pyrrolidinone", "3-methyl-2-oxobutyrate"), "UDN058"]
data_mx[c("glycerophosphoglycerol", "2-pyrrolidinone", "1-(1-enyl-palmitoyl)-2-palmitoleoyl-gpc (p-16:0/16:1)", "phosphate"), "UDN059"]
data_mx[c("2-pyrrolidinone", "gamma-glutamylhistidine", "taurocholate"), "UDN096"]
data_mx[c("1,2-dipalmitoyl-gpc (16:0/16:0)", "glucuronate", "n-acetylmethionine", "succinimide"), "UDN099"]
data_mx[c("glutamine", "3-methoxytyrosine", "p-cresol sulfate", "lysine"), "UDN103"]
data_mx[c("glutamine", "13-hode + 9-hode", "2-pyrrolidinone", "leucylleucine", "pyroglutamylvaline", "aconitate [cis or trans]", "asparagine"), "UDN121"]
data_mx[c("n-acetylaspartate (naa)", "anserine", "2-pyrrolidinone", "4-guanidinobutanoate", "erythritol"), "UDN154"]




#### JACCARD SET SIMILARITY (w/ Directionality) ####
alpha=0.0
print(sprintf("CTDsim for alpha = %.2f...", alpha))
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/single-node")
res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "abat"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_abat = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_abat) = 0

res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "aadc"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_aadc = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_aadc) = 0

res_all = loadToEnv(sprintf("sn_ptSim_%s_norm.RData", "adsl"))[["res_all"]]
res_tmp = lapply(res_all, function(i) i$ncd)
res_tmp2 = lapply(res_all, function(i) i$jac)
res_adsl = alpha*mle.getMinPtDistance(res_tmp) + (1-alpha)*mle.getMinPtDistance(res_tmp2)
diag(res_adsl) = 0

res_overall = mle.getMinPtDistance(list(res_abat, res_aadc, res_adsl))
colnames(res_overall) = colnames(res_all[[1]]$ncd)
res_overall[which(res_overall<0)] = 0
res_overall = res_overall/max(res_overall)

diags = colnames(res_all[[1]]$ncd)
diags = gsub("[[:digit:]]", "", diags)

# CTD Kmeans K=4
aadc.centroid = apply(res_overall[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(res_overall[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(res_overall[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(res_overall[which(diags=="REF"),], 2, mean)
kmns = kmeans(res_overall, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(res_overall))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
c2 = df[which(df[,1]=="2"), "diag"]
c3 = df[which(df[,1]=="3"), "diag"]
c4 = df[which(df[,1]=="4"), "diag"]



```

``` {r compare_naive_dist}
#### COMPARE TO VECTOR-BASED DISTANCE METRICS ####
#setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/multi-node")
rm(list=ls())
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Methods_paper/ptSim/v2/single-node")
imputeMissingValues = function(data, ref) {
  data = data[which(rownames(data) %in% rownames(ref)),]
  ref = ref[which(rownames(ref) %in% rownames(data)),]
  data = data[sort(rownames(data)),]
  ref = ref[sort(rownames(ref)),]
  
  imputed.data = data
  for (met in 1:nrow(ref)) {
    rowData = ref[met,]
    if (any(is.na(rowData))) {
      rowData = as.numeric(rowData[-which(is.na(rowData))])
    } else {
      rowData = as.numeric(rowData)
    }
    # Impute using uniform random variable, where a = 0.99*observed minimum, and b = observed minimum
    min_row = min(rowData)
    if (min_row<0) {
      min_row = -1*min_row
      imputed.data[met, is.na(data[met,])] = tryCatch(-1*runif(sum(is.na(data[met,])), min = 0.99*min_row, max= min_row), 
                                                      error = function(e) e, warning=function(w) print(sprintf("%s: met%d", w, met)))
    } else {
      imputed.data[met, is.na(data[met,])] = tryCatch(runif(sum(is.na(data[met,])), min = 0.99*min(rowData), max= min(rowData)), 
                                                      error = function(e) e, warning=function(w) print(sprintf("%s: met%d", w, met)))
    }
  }
  return(imputed.data)
}

require(CTD)
data(Thistlethwaite2019)
data_mx = as.matrix(data_mx)
data_mx = suppressWarnings(apply(data_mx, c(1,2), as.numeric))
data_mx = data_mx[,-c(1,2,3,4,5,6,7,8)]
ref_data = data_mx[, grep("REF", colnames(data_mx))]
load("sn_ptSim_aadc_norm.RData")
data_mx = data_mx[, which(colnames(data_mx) %in% colnames(res_all[[1]]$ncd))]
data_mx = imputeMissingValues(data_mx, ref_data)

diags = colnames(data_mx)
diags = gsub("[[:digit:]]", "", diags)
  

cov_d = cov(t(data_mx))
mah = mahalanobis(x = t(data_mx), center = colMeans(t(data_mx)), cov=cov_d, tol=1e-25)


require(Hmisc)
pearson = rcorr(data_mx, type="pearson")
pearson = pearson$r
pearson = 1 - pearson
for (pt in 1:ncol(data_mx)) {
  pearson[pt,] = pearson[pt,] + abs(min(pearson[pt,]))
  pearson[pt,] = pearson[pt,]/abs(max(pearson[pt,]))
}
pear_p = plot.mdsSim(pearson, diags, 2, NULL)
orca(pear_p, "pearson_v2.png")
mx = as.matrix(dist(t(data_mx), method="maximum"))
for (pt in 1:ncol(data_mx)) {
  mx[pt,] = mx[pt,] + abs(min(mx[pt,]))
  mx[pt,] = mx[pt,]/abs(max(mx[pt,]))
}
mx_p = plot.mdsSim(mx, diags, 2, NULL)
orca(mx_p, "mx_v2.png")
euc = as.matrix(dist(t(data_mx), method="euclidean"))
for (pt in 1:ncol(data_mx)) {
  euc[pt,] = euc[pt,] + abs(min(euc[pt,]))
  euc[pt,] = euc[pt,]/abs(max(euc[pt,]))
}
euc_p = plot.mdsSim(euc, diags, 2, NULL)
orca(euc_p, "euc_v2.png")
man = as.matrix(dist(t(data_mx), method="manhattan"))
for (pt in 1:ncol(data_mx)) {
  man[pt,] = man[pt,] + abs(min(man[pt,]))
  man[pt,] = man[pt,]/abs(max(man[pt,]))
}
man_p = plot.mdsSim(man, diags, 2, NULL)
orca(man_p, "man_v2.png")

# Pearson
aadc.centroid = apply(pearson[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(pearson[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(pearson[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(pearson[which(diags=="REF"),], 2, mean)
kmns = kmeans(pearson, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(pearson))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
c2 = df[which(df[,1]=="2"), "diag"]
c3 = df[which(df[,1]=="3"), "diag"]
c4 = df[which(df[,1]=="4"), "diag"]

c1 = df[which(df[,1]=="1"), "diag"]
if (length(which(c1=="UDN"))>0) { c1 = c1[-which(c1=="UDN")] }
c2 = df[which(df[,1]=="2"), "diag"]
if (length(which(c2=="UDN"))>0) { c2 = c2[-which(c2=="UDN")] }
c3 = df[which(df[,1]=="3"), "diag"]
if (length(which(c3=="UDN"))>0) { c3 = c3[-which(c3=="UDN")] }
c4 = df[which(df[,1]=="4"), "diag"]
if (length(which(c4=="UDN"))>0) { c4 = c4[-which(c4=="UDN")] }

tp = length(which(c1=="AADC")) 
tn = length(c(which(c2!="AADC"), which(c3!="AADC"), which(c4!="AADC")))
fp = length(c(which(c2=="AADC"), which(c3=="AADC"), which(c4=="AADC")))
c1_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c1_prec = tp/(fp+tp)
tp = length(which(c2=="ABAT")) 
tn = length(c(which(c1!="ABAT"), which(c3!="ABAT"), which(c4!="ABAT")))
fp = length(c(which(c1=="ABAT"), which(c3=="ABAT"), which(c4=="ABAT")))
c2_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c2_prec = tp/(fp+tp)
tp = length(which(c3=="ADSL")) 
tn = length(c(which(c1!="ADSL"), which(c2!="ADSL"), which(c4!="ADSL")))
fp = length(c(which(c1=="ADSL"), which(c2=="ADSL"), which(c4=="ADSL")))
c3_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c3_prec = tp/(fp+tp)
tp = length(which(c4=="REF")) 
tn = length(c(which(c1!="REF"), which(c2!="REF"), which(c3!="REF")))
fp = length(c(which(c1=="REF"), which(c2=="REF"), which(c3=="REF")))
c4_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c4_prec = tp/(fp+tp)
  
mean(c(c1_acc, c2_acc, c3_acc, c4_acc))
mean(c(c1_prec, c2_prec, c3_prec, c4_prec))


# Euclidean
aadc.centroid = apply(euc[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(euc[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(euc[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(euc[which(diags=="REF"),], 2, mean)
kmns = kmeans(euc, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(euc))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
c2 = df[which(df[,1]=="2"), "diag"]
c3 = df[which(df[,1]=="3"), "diag"]
c4 = df[which(df[,1]=="4"), "diag"]

c1 = df[which(df[,1]=="1"), "diag"]
if (length(which(c1=="UDN"))>0) { c1 = c1[-which(c1=="UDN")] }
c2 = df[which(df[,1]=="2"), "diag"]
if (length(which(c2=="UDN"))>0) { c2 = c2[-which(c2=="UDN")] }
c3 = df[which(df[,1]=="3"), "diag"]
if (length(which(c3=="UDN"))>0) { c3 = c3[-which(c3=="UDN")] }
c4 = df[which(df[,1]=="4"), "diag"]
if (length(which(c4=="UDN"))>0) { c4 = c4[-which(c4=="UDN")] }

tp = length(which(c1=="AADC")) 
tn = length(c(which(c2!="AADC"), which(c3!="AADC"), which(c4!="AADC")))
fp = length(c(which(c2=="AADC"), which(c3=="AADC"), which(c4=="AADC")))
c1_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c1_prec = tp/(fp+tp)
tp = length(which(c2=="ABAT")) 
tn = length(c(which(c1!="ABAT"), which(c3!="ABAT"), which(c4!="ABAT")))
fp = length(c(which(c1=="ABAT"), which(c3=="ABAT"), which(c4=="ABAT")))
c2_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c2_prec = tp/(fp+tp)
tp = length(which(c3=="ADSL")) 
tn = length(c(which(c1!="ADSL"), which(c2!="ADSL"), which(c4!="ADSL")))
fp = length(c(which(c1=="ADSL"), which(c2=="ADSL"), which(c4=="ADSL")))
c3_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c3_prec = tp/(fp+tp)
tp = length(which(c4=="REF")) 
tn = length(c(which(c1!="REF"), which(c2!="REF"), which(c3!="REF")))
fp = length(c(which(c1=="REF"), which(c2=="REF"), which(c3=="REF")))
c4_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c4_prec = tp/(fp+tp)
  
mean(c(c1_acc, c2_acc, c3_acc, c4_acc))
mean(c(c1_prec, c2_prec, c3_prec, c4_prec))


# Maximum
aadc.centroid = apply(mx[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(mx[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(mx[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(mx[which(diags=="REF"),], 2, mean)
kmns = kmeans(mx, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(mx))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
if (length(which(c1=="UDN"))>0) { c1 = c1[-which(c1=="UDN")] }
c2 = df[which(df[,1]=="2"), "diag"]
if (length(which(c2=="UDN"))>0) { c2 = c2[-which(c2=="UDN")] }
c3 = df[which(df[,1]=="3"), "diag"]
if (length(which(c3=="UDN"))>0) { c3 = c3[-which(c3=="UDN")] }
c4 = df[which(df[,1]=="4"), "diag"]
if (length(which(c4=="UDN"))>0) { c4 = c4[-which(c4=="UDN")] }

tp = length(which(c1=="AADC")) 
tn = length(c(which(c2!="AADC"), which(c3!="AADC"), which(c4!="AADC")))
fp = length(c(which(c2=="AADC"), which(c3=="AADC"), which(c4=="AADC")))
c1_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c1_prec = tp/(fp+tp)
tp = length(which(c2=="ABAT")) 
tn = length(c(which(c1!="ABAT"), which(c3!="ABAT"), which(c4!="ABAT")))
fp = length(c(which(c1=="ABAT"), which(c3=="ABAT"), which(c4=="ABAT")))
c2_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c2_prec = tp/(fp+tp)
tp = length(which(c3=="ADSL")) 
tn = length(c(which(c1!="ADSL"), which(c2!="ADSL"), which(c4!="ADSL")))
fp = length(c(which(c1=="ADSL"), which(c2=="ADSL"), which(c4=="ADSL")))
c3_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c3_prec = tp/(fp+tp)
tp = length(which(c4=="REF")) 
tn = length(c(which(c1!="REF"), which(c2!="REF"), which(c3!="REF")))
fp = length(c(which(c1=="REF"), which(c2=="REF"), which(c3=="REF")))
c4_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c4_prec = tp/(fp+tp)
  
mean(c(c1_acc, c2_acc, c3_acc, c4_acc))
mean(c(c1_prec, c2_prec, c3_prec, c4_prec))

# Manhattan
aadc.centroid = apply(man[which(diags=="AADC"),], 2, mean)
abat.centroid = apply(man[which(diags=="ABAT"),], 2, mean)
adsl.centroid = apply(man[which(diags=="ADSL"),], 2, mean)
negCntl.centroid = apply(man[which(diags=="REF"),], 2, mean)
kmns = kmeans(man, centers = rbind(aadc.centroid, abat.centroid, adsl.centroid, negCntl.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(man))
colnames(df) = c("cluster.num", "diag", "ptID")
c1 = df[which(df[,1]=="1"), "diag"]
if (length(which(c1=="UDN"))>0) { c1 = c1[-which(c1=="UDN")] }
c2 = df[which(df[,1]=="2"), "diag"]
if (length(which(c2=="UDN"))>0) { c2 = c2[-which(c2=="UDN")] }
c3 = df[which(df[,1]=="3"), "diag"]
if (length(which(c3=="UDN"))>0) { c3 = c3[-which(c3=="UDN")] }
c4 = df[which(df[,1]=="4"), "diag"]
if (length(which(c4=="UDN"))>0) { c4 = c4[-which(c4=="UDN")] }

tp = length(which(c1=="AADC")) 
tn = length(c(which(c2!="AADC"), which(c3!="AADC"), which(c4!="AADC")))
fp = length(c(which(c2=="AADC"), which(c3=="AADC"), which(c4=="AADC")))
c1_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c1_prec = tp/(fp+tp)
tp = length(which(c2=="ABAT")) 
tn = length(c(which(c1!="ABAT"), which(c3!="ABAT"), which(c4!="ABAT")))
fp = length(c(which(c1=="ABAT"), which(c3=="ABAT"), which(c4=="ABAT")))
c2_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c2_prec = tp/(fp+tp)
tp = length(which(c3=="ADSL")) 
tn = length(c(which(c1!="ADSL"), which(c2!="ADSL"), which(c4!="ADSL")))
fp = length(c(which(c1=="ADSL"), which(c2=="ADSL"), which(c4=="ADSL")))
c3_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c3_prec = tp/(fp+tp)
tp = length(which(c4=="REF")) 
tn = length(c(which(c1!="REF"), which(c2!="REF"), which(c3!="REF")))
fp = length(c(which(c1=="REF"), which(c2=="REF"), which(c3=="REF")))
c4_acc = (tp+tn)/length(c(c1, c2, c3, c4))
c4_prec = tp/(fp+tp)
  
mean(c(c1_acc, c2_acc, c3_acc, c4_acc))
mean(c(c1_prec, c2_prec, c3_prec, c4_prec))

```

